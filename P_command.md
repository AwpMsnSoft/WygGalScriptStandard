# 流程控制指令（P指令）

## 分支判断指令（PIF指令）:
- **本文档并非包括所有分支判断指令。**  
- 找不到匹配的分支判断指令，或找不到跳转的位置，为关键错误。
--------
- wgs的使用者分别理解每个分支判断指令的详细说明是没有必要的，可以直接套用以下格式，请合理使用缩进以保证wgs层次明确： 

- .if和.endif的用法
    ```
    ##若$state为真，执行##do_things处的语句，否则跳过：
    .if $state
        ##do_things
    .endif
    ```
- 逻辑运算和嵌套的用法
    ```
    ##只有$state_1和$state_2全部为真，才执行##do_things处的语句，否则跳过：
    .if $state_1&$state_2
        ##do_things
    .endif
    ##允许嵌套，也可以这样：
    .if $state_1
        .if $state_2
            ##do_things
        .endif
    .endif
    ```
    ```
    ##若$state_1和$state_2至少有一个为真，执行##do_things处的语句，否则跳过：
    .if $state_1|$state_2
        ##do_things
    .endif
    ```
    ```
    ##只有$state_1和$state_2全部为假，才执行##do_things处的语句，否则跳过：
    .if !$state_1&!$state_2
        ##do_things
    .endif
    ## !运算优先级最高，可以使用括号：
    .if !($state_1|$state_2)
        ##do_things
    .endif
    ```
- .else 的用法    
    ```
    ##若$state为真，执行##do_things_1处的语句，否则执行##do_things_2处的语句：
    .if $state
        ##do_things_1
    .else
        ##do_things_2
    .endif
    ```
- .elseif 的用法
    ```
    ##若$state_1为真，执行##do_things_1处的语句，
    ##否则若$state_2为真则执行##do_things_2处的语句，
    ##否则若$state_3为真则执行##do_things_3处的语句，
    ##否则执行##do_things_4处的语句：

    .if $state_1
        ##do_things_1
    .elseif $state_2
        ##do_things_2
    .elseif $state_3
        ##do_things_3
    .else
        ##do_things_4
    .endif

    ##可以改写成嵌套形式：
    .if $state_1
        ##do_things_1
    .else
        .if $state_2
            ##do_things_2
        .else
            .if $state_3
                ##do_things_3
            .else
                ##do_things_4
            .endif
        .endif    
    .endif

    ```


### 以下是分支判断指令的详细说明:
--------
### **.if**  
> 概述：这是一个.if类指令，判断表达式的值是否为真，以进入下方不同的分支。   


- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |BoolExpr|False|||✔||✔||✔|

- 指令说明：
    - 根据**BoolExpr**的值决定：   
    **True**：继续执行，直至遇到匹配的.else类或.endif指令，再从匹配的.endif指令继续；   
    **False**：跳转到下一个匹配的.else类或.endif指令。 
--------
### **.else**  
> 概述：这是一个.else类指令，可以作为最后一个分支开始的标记。 
- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |无|||||||||
    
- 指令说明：
    - 与前一个未被.endif匹配的.if类指令匹配。 
--------
### **.endif**  
> 概述：这是最后一个判断分支结束的标记。 
- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |无|||||||||
    
- 指令说明：
    - 与前一个尚未被.endif匹配的.if类且非.else类指令匹配，并且与二者之间所有尚未被.endif匹配的.if类和.else类指令匹配。
        
--------
### **.elseif**  
> 概述：这是一个.else类或.if类指令，该指令未被跳过时，判断表达式的值是否为真，以进入下方的不同分支。 
- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |BoolExpr|False|||✔||✔||✔|

- 指令说明：
    - 根据**BoolExpr**的值决定：   
    **True**：继续执行，直至遇到匹配的.else类或.endif指令，再从匹配的.endif指令继续；   
    **False**：跳转到下一个匹配的.else类或.endif指令。 
--------


## 循环控制指令(PLOOP指令)
- **本文档并非包括所有循环控制指令。**  
- 找不到匹配的循环控制指令，或找不到跳转的位置，为关键错误。
--------  
- 使用循环控制指令可以反复执行一些语句，可以直接套用以下格式，请合理使用缩进以保证wgs层次明确：

- .loop和.endloop的用法：
    ```
    ##.loop为循环的开头，.endloop为循环的结尾，循环即反复执行##repeat_do_things处的语句，
    ##当执行到.endloop时，会回到.loop的位置：
    .loop
        ##repeat_do_things
    .endloop
    ```
- .continue和循环内嵌套判断的用法：    
    ```
    ##若执行.continue，则立即回到当前循环的.loop处，
    ##可以通过判断$state是否为True来决定是否提前开始下一轮循环：
    .loop
        ##script_1
        .if $state 
            ##do_things_before_continue
            .continue
        .endif
        ##script_2
    .endloop
    ```
- .break的和循环内嵌套判断的用法：    
    ```
    ##若执行.break，则立即结束循环，跳到当前循环的.endloop之后，
    ##可以通过判断$state是否为True来决定是否退出当前循环：
    .loop
        ##script_1
        .if $state 
            ##do_things_before_break
            .break
        .endif
        ##script_2
    .endloop
    ```
- 反复执行有限次数的循环可通过变量和.break实现：
    ```
    ##执行##repeat_do_things处的语句100次：
    .defvar $i 0
    .loop
        .if $i>=100
            .break
        .endif
        ##repeat_do_things
        $i = $i+1
    .endloop    
    .undef $i
    ```
- 循环允许嵌套，例如：    
    ```
    ##执行##repeat_do_things处的语句1+2+3+4+...+100次：
    .defvar $i 0
    .defvar $j
    .loop
        .if $i>=100
            .break
        .endif
        $j = 0
        .loop
            .if $j>$i
                .break
            .endif
            ##repeat_do_things
            $j = $j+1
        .endloop
        $i = $i+1
    .endloop
    .undef $j    
    .undef $i
    ```

### 以下是循环控制指令的详细说明:
--------
### **.loop**  
> 概述：作为循环的开始标记。   


- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |无|||||||||

- 指令说明：
    - .loop作为循环的开始，总是与作为循环结尾的.endloop成对出现。
--------
### **.endloop**  
> 概述：作为循环的结尾标记。   


- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |无|||||||||

- 指令说明：
    - .endloop作为循环的结尾，总是与作为循环开始的.loop成对出现；
    - 与前一个尚未被.endloop匹配的.loop匹配。

--------
### **.continue**  
> 概述：在当前循环中，提前完成本轮并立即开始下一轮。   

- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |无|||||||||

- 指令说明：
    - 在嵌套循环中，只对最内层循环生效；
    - 总是跳转到前一个作为当前循环开始的.loop处。

--------

### **.break**  
> 概述：立即结束当前循环。   

- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |无|||||||||

- 指令说明：
    - 在嵌套循环中，只对最内层循环生效；
    - 总是跳转到下一个作为当前循环结尾的.endloop之后。

--------

## 跨文件跳转指令 (PCWGS指令)

- 要切换到其他wgs文件，需使用跨文件跳转指令。
- 找不到要切换到的wgs文件，为关键错误。
--------
### **.chain**  
> 概述：离开当前正在执行的wgs文件，跳转到另一个wgs文件，从第一行开始执行。   

- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |WgsFileName||✔||||✔||✔|

- 指令说明：

    - WgsFileName指代需要跳转到的wgs文件，解释器会首先检索缓存中是否有对应文件，如果有则直接使用缓存，否则向引擎请求获取。
    - **.chain指令的第一个参数WgsFileName支持语法逃逸：在不引发歧义的情况下，文本常量一般不加双引号：**
    ```
        ##下列2条指令是等价的
        .chain stage1
        .chain "stage1" 
    ```
    - **WgsFileName是否省略扩展名".wgs"，引擎和解释器必须保证二者等价：**
    ```
        ##下列4条指令是等价的
        .chain WgsNoExten
        .chain WgsNoExten.wgs
        .chain "WgsNoExten"
        .chain "WgsNoExten.wgs"
    ```
    - WgsFileName允许包含目录，允许使用相对路径，不建议使用绝对路径，**如果使用了目录，或引发歧义的用法，则文本常量必须加双引号，否则无法实现预期目标**。
    - WgsFileName指代的文件不一定为硬盘上的文本文件，它可能是某个文件的一部分，或加密的文本文件，或网络请求的返回数据，或内存空间中的数据，或随机生成的脚本。
    - WgsFileName允许指代当前正在使用的wgs文件，相当于回当前wgs的第一行，这可能因变量的重定义而引发关键错误，应在变量失去作用后解除定义，或者一开始就使用.redefvar而不是.defvar指令。
    - WgsFileName是否区分大小写取决于系统环境和具体实现，所以在编写wgs文件时，WgsFileName应严格区分大小写，且不应出现不同文件名称仅大小写不同的情况。

--------
### **.call**  
> 概述：离开当前正在执行的wgs文件，跳转到另一个wgs文件，从第一行开始执行，执行完成后回到原先wgs的.call指令之后。相当于执行一个通过全局变量传递信息的函数。   

- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |WgsFileName||✔||||✔||✔|

- 指令说明：

    - **.call指令的第一个参数WgsFileName支持语法逃逸，意义和用法与.chain指令基本相同。**
    - 与.chain指令不同的是，.call指令会在新的wgs执行完成后回到原先wgs的.call指令之后；为实现此功能，解释器需于跳转前，在调用堆栈中记录当前所在的wgs及执行到的位置，需要消耗一定资源，且有堆栈溢出风险；   
    - 使用.call指令，跳转到先前离开的若干wgs文件可能性更大，更容易因变量的重定义而引发关键错误，应在变量失去作用后解除定义，或者一开始就使用.redefvar而不是.defvar指令；
    - **因此：若能使用.chain指令满足需求，就应当使用.chain指令而不是.call指令。**
   
--------
### **.flushwgs**  
> 概述：清空解释器的wgs缓存。 
- 参数列表
    |参数名称|默认值|文本|数|布尔|数组|输入|输出|表达式空格|
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    |无|||||||||
    
- 指令说明：
    - 解释器若支持缓存功能，则清空缓存的wgs文件（不清空正在使用和调用堆栈中记录的wgs文件缓存），否则什么也不做；
    - 本指令具有两个作用，一是减少内存消耗，二是用于接收解释器外随机生成的wgs文件。重新请求并接收被清空缓存的wgs需要额外时间。
--------



